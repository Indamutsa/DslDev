/**
 * generated by Xtext 2.24.0
 */
package org.example.expression.generator;

import com.google.common.collect.Iterables;
import com.google.inject.Inject;
import java.util.function.Consumer;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.eclipse.xtext.nodemodel.util.NodeModelUtils;
import org.eclipse.xtext.xbase.lib.Extension;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;
import org.example.expression.expression.AbstractElement;
import org.example.expression.expression.ExpressionsModel;
import org.example.expression.interpreter.ExpressionInterpreter;

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
@SuppressWarnings("all")
public class ExpressionGenerator extends AbstractGenerator {
  @Inject
  @Extension
  private ExpressionInterpreter _expressionInterpreter;
  
  /**
   * Differently from the code generator we saw in Chapter 5, Code Generation, here we
   * generate a single text file for each input file (an input file is represented by an EMF
   * Resource ); the name of the output file is the same as the input file (retrieved by taking
   * the last part of the URI of the resource), with an additional evaluated file extension.
   */
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    final Consumer<ExpressionsModel> _function = (ExpressionsModel it) -> {
      StringConcatenation _builder = new StringConcatenation();
      String _lastSegment = resource.getURI().lastSegment();
      _builder.append(_lastSegment);
      _builder.append(".evaluated");
      _builder.newLineIfNotEmpty();
      fsa.generateFile(_builder.toString(), 
        this.interpretExpressions(it));
    };
    Iterables.<ExpressionsModel>filter(IteratorExtensions.<EObject>toIterable(resource.getAllContents()), ExpressionsModel.class).forEach(_function);
  }
  
  public String interpretExpressions(final ExpressionsModel model) {
    final Function1<AbstractElement, String> _function = (AbstractElement it) -> {
      StringConcatenation _builder = new StringConcatenation();
      String _tokenText = NodeModelUtils.getTokenText(NodeModelUtils.getNode(it));
      _builder.append(_tokenText);
      _builder.append(" ~> ");
      Object _interpret = this._expressionInterpreter.interpret(it);
      _builder.append(_interpret);
      _builder.newLineIfNotEmpty();
      return _builder.toString();
    };
    return IterableExtensions.join(ListExtensions.<AbstractElement, String>map(model.getElements(), _function), "\n");
  }
}
