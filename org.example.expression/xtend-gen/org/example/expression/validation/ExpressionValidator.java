/**
 * generated by Xtext 2.24.0
 */
package org.example.expression.validation;

import com.google.common.base.Objects;
import com.google.inject.Inject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Extension;
import org.example.expression.expression.And;
import org.example.expression.expression.Comparison;
import org.example.expression.expression.Equality;
import org.example.expression.expression.Expression;
import org.example.expression.expression.ExpressionPackage;
import org.example.expression.expression.Minus;
import org.example.expression.expression.MulOrDiv;
import org.example.expression.expression.Not;
import org.example.expression.expression.Or;
import org.example.expression.expression.Plus;
import org.example.expression.expression.Variable;
import org.example.expression.expression.VariableRef;
import org.example.expression.typing.ExpressionType;
import org.example.expression.typing.ExpressionTypeComputer;
import org.example.expression.validation.AbstractExpressionValidator;
import org.example.expression.validation.ExpressionsModelUtil;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class ExpressionValidator extends AbstractExpressionValidator {
  protected static final String ISSUE_CODE_PREFIX = "org.example.expression.";
  
  public static final String FORWARD_REFERENCE = (ExpressionValidator.ISSUE_CODE_PREFIX + "ForwardReference");
  
  public static final String TYPE_MISMATCH = (ExpressionValidator.ISSUE_CODE_PREFIX + "TypeMismatch");
  
  @Inject
  @Extension
  private ExpressionsModelUtil _expressionsModelUtil;
  
  @Inject
  @Extension
  private ExpressionTypeComputer _expressionTypeComputer;
  
  /**
   * For Not , And , and Or , we check that the sub-expressions have type boolean, and
   * we pass the EMF features corresponding to the sub-expression. (The case for Or
   * is similar to the case of And and it is therefore not shown).
   * Following the same approach, it is easy to check that the sub-expressions of Minus
   * and MultiOrDiv both have integer types (we leave this as an exercise, but you can
   * look at the sources of the example).
   * For an Equality expression, we must check that the two sub-expressions have the
   * same type. This holds true also for a Comparison expression, but in this case, we also
   * check that the sub-expressions do not have type boolean, since in our DSL, we do not
   * want to compare two boolean values. The implementation of these @Check methods
   * are as follows, using two additional reusable methods
   */
  @Check
  public void checkForwardReference(final VariableRef varRef) {
    final Variable variable = varRef.getVariable();
    boolean _isVariableDefinedBefore = this._expressionsModelUtil.isVariableDefinedBefore(varRef);
    boolean _not = (!_isVariableDefinedBefore);
    if (_not) {
      String _name = variable.getName();
      String _plus = ("variable forward reference not allowed: \'" + _name);
      String _plus_1 = (_plus + "\'");
      this.error(_plus_1, 
        ExpressionPackage.eINSTANCE.getVariableRef_Variable(), ExpressionValidator.FORWARD_REFERENCE, variable.getName());
    }
  }
  
  @Check
  public void checkType(final Not not) {
    this.checkExpectedBoolean(not.getExpression(), ExpressionPackage.Literals.NOT__EXPRESSION);
  }
  
  @Check
  public void checkType(final And and) {
    this.checkExpectedBoolean(and.getLeft(), ExpressionPackage.Literals.AND__LEFT);
    this.checkExpectedBoolean(and.getRight(), ExpressionPackage.Literals.AND__RIGHT);
  }
  
  @Check
  public void checkType(final Or or) {
    this.checkExpectedBoolean(or.getLeft(), ExpressionPackage.Literals.OR__LEFT);
    this.checkExpectedBoolean(or.getRight(), ExpressionPackage.Literals.OR__RIGHT);
  }
  
  @Check
  public void checkType(final MulOrDiv mulOrDiv) {
    this.checkExpectedInt(mulOrDiv.getLeft(), ExpressionPackage.Literals.MUL_OR_DIV__LEFT);
    this.checkExpectedInt(mulOrDiv.getRight(), ExpressionPackage.Literals.MUL_OR_DIV__RIGHT);
  }
  
  @Check
  public void checkType(final Minus minus) {
    this.checkExpectedInt(minus.getLeft(), ExpressionPackage.Literals.MINUS__LEFT);
    this.checkExpectedInt(minus.getRight(), ExpressionPackage.Literals.MINUS__RIGHT);
  }
  
  @Check
  public void checkType(final Equality equality) {
    final ExpressionType leftType = this.getTypeAndCheckNotNull(equality.getLeft(), ExpressionPackage.Literals.EQUALITY__LEFT);
    final ExpressionType rightType = this.getTypeAndCheckNotNull(equality.getRight(), ExpressionPackage.Literals.EQUALITY__RIGHT);
    this.checkExpectedSame(leftType, rightType);
  }
  
  @Check
  public void checkType(final Comparison comparison) {
    final ExpressionType leftType = this.getTypeAndCheckNotNull(comparison.getLeft(), ExpressionPackage.Literals.COMPARISON__LEFT);
    final ExpressionType rightType = this.getTypeAndCheckNotNull(comparison.getRight(), ExpressionPackage.Literals.COMPARISON__RIGHT);
    this.checkExpectedSame(leftType, rightType);
    this.checkNotBoolean(leftType, ExpressionPackage.Literals.COMPARISON__LEFT);
    this.checkNotBoolean(rightType, ExpressionPackage.Literals.COMPARISON__RIGHT);
  }
  
  /**
   * The final check concerns the Plus expression; according to our type system, if one
   * of the two sub-expressions has type string, everything is fine and therefore all
   * these combinations are accepted as valid: string+string, int+int, string+boolean,
   * and string+int (and the corresponding specular cases). We cannot add two boolean
   * expressions or an integer and a boolean. Therefore, when one of the two
   * sub-expressions has type integer or when they both have a type different from
   * string, we must check that they do not have type boolean
   */
  @Check
  public void checkType(final Plus plus) {
    final ExpressionType leftType = this.getTypeAndCheckNotNull(plus.getLeft(), ExpressionPackage.Literals.PLUS__LEFT);
    final ExpressionType rightType = this.getTypeAndCheckNotNull(plus.getRight(), ExpressionPackage.Literals.PLUS__RIGHT);
    if (((this._expressionTypeComputer.isIntType(leftType) || this._expressionTypeComputer.isIntType(rightType)) || ((!this._expressionTypeComputer.isStringType(leftType)) && (!this._expressionTypeComputer.isStringType(rightType))))) {
      this.checkNotBoolean(leftType, ExpressionPackage.Literals.PLUS__LEFT);
      this.checkNotBoolean(rightType, ExpressionPackage.Literals.PLUS__RIGHT);
    }
  }
  
  private void checkExpectedSame(final ExpressionType left, final ExpressionType right) {
    if ((((right != null) && (left != null)) && (!Objects.equal(right, left)))) {
      this.error(((("expected the same type, but was " + left) + ", ") + right), 
        ExpressionPackage.Literals.EQUALITY.getEIDAttribute(), ExpressionValidator.TYPE_MISMATCH);
    }
  }
  
  private void checkNotBoolean(final ExpressionType type, final EReference reference) {
    boolean _isBoolType = this._expressionTypeComputer.isBoolType(type);
    if (_isBoolType) {
      this.error("cannot be boolean", reference, ExpressionValidator.TYPE_MISMATCH);
    }
  }
  
  private void checkExpectedBoolean(final Expression exp, final EReference reference) {
    this.checkExpectedType(exp, ExpressionTypeComputer.BOOL_TYPE, reference);
  }
  
  private void checkExpectedInt(final Expression exp, final EReference reference) {
    this.checkExpectedType(exp, ExpressionTypeComputer.INT_TYPE, reference);
  }
  
  private void checkExpectedType(final Expression exp, final ExpressionType expectedType, final EReference reference) {
    final ExpressionType actualType = this.getTypeAndCheckNotNull(exp, reference);
    boolean _notEquals = (!Objects.equal(actualType, expectedType));
    if (_notEquals) {
      this.error(
        ((("expected " + expectedType) + " type, but was ") + actualType), reference, 
        ExpressionValidator.TYPE_MISMATCH);
    }
  }
  
  private ExpressionType getTypeAndCheckNotNull(final Expression exp, final EReference reference) {
    ExpressionType _typeFor = null;
    if (exp!=null) {
      _typeFor=this._expressionTypeComputer.typeFor(exp);
    }
    final ExpressionType type = _typeFor;
    if ((type == null)) {
      this.error("null type", reference, ExpressionValidator.TYPE_MISMATCH);
    }
    return type;
  }
}
