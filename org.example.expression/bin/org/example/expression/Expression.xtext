grammar org.example.expression.Expression with org.eclipse.xtext.common.Terminals

generate expression "http://www.example.org/expression/Expression"

ExpressionsModel:
	elements+=AbstractElement*;

/**
 * 
 * If we write something as follows:
 * 	ExpressionsModel:
 * 		variables += Variable*
 * 		evaluations += EvalExpression*
 * 	;
 * We will not be able to write a program where variables and evaluations can be
 * defined in any order; we can only write variables first and then evaluations.
 * To achieve the desired flexibility, we introduce an abstract class for both variable
 * declarations and evaluations; then, our model will consist of a (possibly empty)
 * sequence of such abstract elements.
 */
AbstractElement:
	Variable | EvalExpression;

Variable:
	'var' name=ID '=' expression=Expression;

EvalExpression:
	'eval' expression=Expression;

/**
 * It is much better to write a separate rule for each element as shown 
 * in the following code snippet, and this will lead to the generation 
 * of separate classes
 * 
 * We add a rule, which accepts a reference to an existing variable as follows
 * 
 */
/**
 * 
 * When moving on to more complex expressions, such as addition, we need to write a
 * recursive rule since the left and right parts of an addition are expressions themselves.
 * It would be natural to express such a rule as follows:
 * 		Expression:
 * 		... as above
 * 		{Plus} left=Expression '+' right=Expression;
 */
// So this will be refactored to return an atomic operation
/**
 * Expression:
 * 	{IntConstant} value=INT | 
 * 	{StringConstant} value=STRING | 	
 * 	{BoolConstant} value=('true'|'false') |
 * 	{VariableRef} variable=[Variable]
 * ;
 */
/**
 * We added a main rule for Expression, which delegates to the first rule to start
 * parsing the expression.
 * There will be no class called
 * PlusOrMinus since only objects of class Plus and Minus will be created by this rule.
 */
Expression:
	Or;

Or returns Expression:
	And ({Or.left=current} "||" right=And)*;

/**
 * Now, we add boolean expressions and comparison expressions to the DSL. Again,
 * we have to deal with their precedence, which is as follows, starting from the ones
 * with less precedence:
 * 1. boolean or (operator | |)
 * 2. boolean and (operator && )
 * 3. equality and dis-equality (operators == and != , respectively)
 * 4. comparisons (operators < , <= , > , and >= )
 * 5. addition and subtraction
 * 6. multiplication and division
 * Following the same strategy for writing the grammar rules, we end up with the
 * following expression grammar:
 */
And returns Expression:
	Equality ({And.left=current} "&&" right=Equality)*;

Equality returns Expression:
	Comparison ({Equality.left=current} op=("==" | "!=")
	right=Comparison)*;

Comparison returns Expression:
	PlusOrMinus ({Comparison.left=current} op=(">=" | "<=" | ">" | "<")
	right=PlusOrMinus)*;

/**
 * If we add a rule for multiplication and
 * division, we must handle their precedence with respect to addition and subtraction.
 * To define the precedence, we must write the rule for the operator with less
 * precedence in terms of the rule for the operator with higher precedence. This
 * means that in the grammar, the rules for operators with less precedence are defined
 * first. Since multiplication and division have higher precedence than addition and
 * subtraction, we modify the grammar as follows:
 */
/**
 * In the preceding rules, we use --returns-- to specify the type of the created objects;
 * thus, the features left and right in the corresponding generated Java classes will be
 * of type Expression .
 */
PlusOrMinus returns Expression:
	MulOrDiv (({Plus.left=current} '+' | {Minus.left=current} '-')
	right=MulOrDiv)*;

MulOrDiv returns Expression:
	Primary ({MulOrDiv.left=current} op=('*' | '/')
	right=Primary)*;

/**
 * 	The parser generated by ANTLR cannot handle left recursion since it relies on a
 * 	top-down strategy. Bottom-up parsers do not have this problem, but they would
 * 	require handling operator precedence (which determines which sub-expressions
 * 	should be evaluated first in a given expression) and associativity (which determines
 * 	how operators of the same precedence are grouped in the absence of parentheses).
 * 	As we will see in this section, left factoring will allow us to implicitly define operator
 * 	precedence and associativity.
 */
Primary returns Expression:
	'(' Expression ')' |
	{Not} "!" expression=Primary |
	Atomic;

Atomic returns Expression:
	{IntConstant} value=INT |
	{StringConstant} value=STRING |
	{BoolConstant} value=('true' | 'false') |
	{VariableRef} variable=[Variable];
/**
 * We could write a single rule for all these constant expressions:
 * 	Expression:
 * 		(intValue=INT)|
 * 		(stringValue=STRING)|
 * 		(boolValue=('true'|'false'));
 * 
 * But, this would not be good. It is generally not a good idea to have constructs that
 * result in a single class that represents multiple language elements, since later when
 * we are performing validation and other operations, we cannot differentiate on class
 * alone and instead have to inspect the corresponding fields.		
 */
